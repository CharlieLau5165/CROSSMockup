/* Generated by AWAG */
import { ChangeDetectorRef, Directive, ViewChild, inject } from '@angular/core';
import { Router } from '@angular/router';
import { NgForm } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { HttpErrorResponse } from '@angular/common/http';
import { TranslateService } from '@ngx-translate/core';

import { AwagCommonService } from './awag-common.service';
import { AwagContextService } from './awag-context.service';
import { AwagLoggerService } from './logger/awag-logger.service';
import { AwagAlertService } from './alert/service/awag-alert.service';
import { AwagLanguageSupportService } from './language-support/awag-language-support.service';
import { AwagError } from './awag-error';
import { AwagVisibility } from './awag-visibility.service';
import { ConfigItem } from './awag-config.service';

/**
 * @description
 * 画面コンポーネントの基底クラス。画面共通処理を提供します。
 */
@Directive({})
export class AwagBaseComponent {

  /**
   * 画面Modelオブジェクト。
   */
  model: any = {};

  /**
   * 画面イベント処理が実行中であることを示すフラグ
   */
  eventProcessing = false;

  /**
   * 画面コンポーネントでSubscribeされたすべてのSubscription
   */
  protected subscription: Subscription = new Subscription();

  /**
   * MKDT処理が実行中であることを示すフラグ
   */
  private mkdtProcessing = true;

  /**
   * handleKeydown() の参照を保存します。
   */
  protected handleKeydownFn: (event: any) => void = () => {
    // noop
  };

  /**
   * メインフォーム。フォーム分割している場合、2つ目以降のフォームはカスタムロジックでの定義が必要です。
   */
  @ViewChild('form', { static: true }) mainForm?: NgForm | null;

  /**
   * 変更検知
   */
  protected changeDetectorRef: ChangeDetectorRef | null = inject(ChangeDetectorRef);

  /**
   * 翻訳サービス
   */
  private readonly _translate: TranslateService = inject(TranslateService);

  /**
   * @constructor
   * @param {Router} router
   * @param {AwagCommonService} awagCommon
   * @param {AwagContextService} awagContext
   * @param {AwagLoggerService} awagLogger
   * @param {AwagAlertService} awagAlert
   * @param {AwagLanguageSupportService} awagLanguageSupport
   */
  constructor(
    protected router: Router,
    protected awagCommon: AwagCommonService,
    protected awagContext: AwagContextService,
    protected awagLogger: AwagLoggerService,
    protected awagAlert: AwagAlertService,
    protected awagLanguageSupport: AwagLanguageSupportService
  ) {
    this.awagContext.setNextUrl(null);
  }

  /**
   * @description
   * デザインタイプを取得します。 返却する値 'BS'
   * @protected
   */
  protected getDesignType() {
    return 'BS';
  }

  /**
   * @description
   * 各画面コンポーネントの初期化処理を実行します。
   * @protected
   */
  protected awagOnInit() {
    this.handleKeydownFn = this.handleKeydown.bind(this);
    window.addEventListener('keydown', this.handleKeydownFn, true);
    this.awagAlert.clearAlerts();
    this.awagCommon.changeCompactView(this.awagCommon.getConfig().get(ConfigItem.COMPACT));
  }

  /**
   * @description
   * 指定した画面の初期表示用のデータとしてawagContextからModelオブジェクトを取得します。onInitイベントで実行されます。
   * - awagContextにnextModelが存在する場合、そのオブジェクトが返却されます。
   * - awagContextにnextModelが存在しない場合、VModel（過去の画面表示モデル）が返却されます。
   * @param {string} screen 画面名
   * @returns {*} 指定した画面名の初期表示用の画面Modelオブジェクト
   */
  protected getModelOnInit(screen: string): any {
    let initModel = this.awagContext.getNextModel();
    if (initModel == null) {
      initModel = this.awagContext.getVModel(screen);
    } else {
      this.awagContext.setNextModel(null);
    }
    // Router外の遷移で表示モデルが見つからない場合は遷移エラーとする
    const navigateFromRouter = this.awagContext.isNavigateFromRouter(false);
    this.awagContext.setNavigateError(!navigateFromRouter && initModel == null);
    
    initModel ??= {};
    return initModel;
  }

  /**
   * @description
   * awagContextからエラー情報を取得します。onInitイベントで実行され、取得されたエラーは画面に初期表示されます。
   * @returns {AwagError} エラー情報
   */
  protected getErrorOnInit(): AwagError | null {
    let error = this.awagContext.getError();
    this.awagContext.setError(null);
    if (this.awagContext.isNavigateError()) {
      error = new AwagError('', this._translate.instant('awag.msg.InvalidNavigate.error'));
    }
    return error;
  }

  /**
   * @description
   * AwagError インスタンスまたはエラーコードを引数として受け取り、エラーを表示します。
   * 
   * @protected
   * @param codeOrError - AwagError のインスタンス、またはエラーコードを文字列として指定します。
   * @param [message=''] - エラーメッセージを指定します。codeOrError が AwagError のインスタンスの場合、このパラメーターは無視されます。省略した場合、デフォルト値は空文字列です。
   */
  protected showMessage(codeOrError: string | AwagError | HttpErrorResponse | null, message = '') {
    this.showError(codeOrError, message);
  }

  /**
   * @description
   * AwagError インスタンスまたはエラーコードを引数として受け取り、エラーを表示します。
   * 
   * @protected
   * @param codeOrError - AwagError のインスタンス、またはエラーコードを文字列として指定します。
   * @param [message=''] - エラーメッセージを指定します。codeOrError が AwagError のインスタンスの場合、このパラメーターは無視されます。省略した場合、デフォルト値は空文字列です。
   */
  protected showError(codeOrError: string | AwagError | HttpErrorResponse | null, message = '') {
    if (codeOrError instanceof HttpErrorResponse) {
      codeOrError = codeOrError.error;
    }
    let error: any;
    if (typeof codeOrError === 'string') {
      error = new AwagError(codeOrError, message);
    } else {
      error = codeOrError;
    }
    if (error != null) {
      if ((error.code || error.code == '') && !error.code?.startsWith('_EVD')) {
        this.awagAlert.pushAlert(error.code, error.message);
      }
      // for client error
      if (error.details != null) {
        error.details.forEach((errordetail: any) => {
          if (errordetail.code) {
            this.awagAlert.pushAlert(errordetail.code, errordetail.message);
          }
        });
      }
      // for server error
      if (error.errors != null) {
        error.errors.forEach((errordetail: any) => {
          if (errordetail.code) {
            this.awagAlert.pushAlert(errordetail.code, errordetail.message);
          }
        });
      }
      this.awagCommon.scrollToTop();
    }
  }

  /**
   * @description
   * フィールドを正常に動作させるためのWork-aroundです。
   */
  private MKDT() {
    this.awagLogger.develop('AwagBaseComponent.MKDT()');
    this.changeDetectorRef?.detectChanges();
  }

  /**
   * @description
   * ラジオボタンとチェックボックスをリセットします（option-AndOrを除く）。
   */
  protected resetChecked() {
    const element = document.getElementById('optionAnd') as HTMLInputElement;
    if (element) {
      element.checked = true;
    }
  }

  /**
   * @description
   * モデルの指定された項目を更新します。
   * @param model モデル
   * @param name 項目名
   * @param value 値
   * @returns 更新されたモデル
   */
  updateModel(model: any, name: string, value: any): any {
    const names = name.split('.');
    for (let i = 0; i <= names.length; i++) {
      if (i === names.length - 1) {
        model[names[i]] = value
        break;
      }
      model = model[names[i]];
    }
    return model;
  }

  /**
   * @description
   * View初期化後の処理。
   */
  protected awagAfterViewInit() {
    this.mkdtProcessing = true;
    if (this.awagContext.getSubContext()?.isReturn()) {
      this.awagContext.setSubContext(null);
    }
    this.eventProcessing = false;
  }

  /**
   * @description
   * ngAfterViewCheckedのライフサイクルイベントでビューの変更への応答処理を行います。
   */
  protected awagAfterViewChecked() {
    if (this.mkdtProcessing) {
      this.MKDT();
      this.mkdtProcessing = false;
    }
  }

  /**
   * @description
   * Navigate next page with the URL specified in the AwagContext.NextUrl. If the NextUrl is null, the navigation will be cancelled.
   * @param {*} [nextModel=null] nextModel Model data which is displayed on the next page.
   */
  protected awagNavigateNextPage(nextModel: any = null) {
    this.awagContext.setNextModel(nextModel);
    let url = this.awagContext.getNextUrl();
    if (url != null) {
      if (this.awagContext.getModalContext() != null) {
        url = this.awagContext.getModalContext()?.getBaseUrl() + '/(modal:' + url + ')';
      }
      this.awagContext.setNavigateFromRouter(true);
      this.router.navigateByUrl(url);
    } else {
      this.awagAfterViewInit();
    }
  }

  /**
   * @description
   * 指定したコード値に対するラベル名を取得します。
   * @param {any[]} nameValues コード値リスト
   * @param {*} value コード値
   * @returns ラベル名
   */
  public getNameFromValue(nameValues: any[], value: any) {
    if (Array.isArray(value)) {
      let name = '';
      value.forEach((v: any) => {
        for (const nameValue of nameValues) {
          if (nameValue.value === v) {
            name = (name.length == 0) ? name + nameValue.name : name + ',' + nameValue.name;
          }
        }
      });
      return (name.length == 0) ? value : name;
    } else {
      for (const nameValue of nameValues) {
        if (nameValue.value === value) {
          return nameValue.name;
        }
      }
      return value;
    }
  }

  /**
   * @description
   * ローディング表示を行います。
   **/
  protected showLoading() {
    this.eventProcessing = true;
    this.awagAlert.clearAlerts();
    document.querySelector('app-root')?.setAttribute('inert', 'true');
    document.getElementById('awagOverlay')!.classList.remove('d-none');
    setTimeout(() => {
      document.getElementById('awagOverlay')!.classList.add('awag-loading-overlay');
    });
  }

  /**
  * @description
  * ローディング表示を非表示にします。
  **/
  protected hideLoading() {
    document.getElementById('awagOverlay')!.classList.add('d-none');
    document.getElementById('awagOverlay')!.classList.remove('awag-loading-overlay');
    document.querySelector('app-root')?.removeAttribute('inert');
  }

  /**
  * @description
  * SideNavの表示状態を指定します。
  */
  protected showDrawer(isShow: boolean) {
    // noop
  }

  /**
   * @description
   * 画面Destroy時の処理。
   * @protected
   */
  protected awagOnDestroy() {
    this.subscription.unsubscribe();
    window.removeEventListener('keydown', this.handleKeydownFn, true);
    this.awagCommon.clearFunctionKey();
    this.handleKeydown = () => {};
    this.mainForm = null;
    this.changeDetectorRef = null;
  }

  /**
   * @description
   * キー押下イベントをフックし、登録されているコールバックメソッドを実行します。
   * @param {*} event
   */
  handleKeydown(event: any) {
    const key = this.awagCommon.functionKeys.filter((functionKey: any) => event.key === functionKey.key)[0];
    if (key) {
      event.preventDefault();
      key.callback();
    }
  }

  /**
   * 遷移先画面のURLを判定して画面遷移処理を継続するか、中断するかを判定処理します。
   * @param nextUrl 遷移先画面のURL
   * @returns 画面遷移処理を継続する場合にはtrue、中断する場合にはfalseを返します
   */
  canDeactivate(nextUrl: string): Observable<boolean> | Promise<boolean> | boolean {
    return true;
  }

  /**
   * @description
   * 対象セクションの項目を非表示にすべきかどうかを判定します。
   * @param sectionName セクション名
   * @param [itemId=null] 項目ID
   * @returns 非表示にすべき項目である場合には`true`を返します
   */
  isVisibilityHidden(sectionName: string, itemId: string | null = null): boolean {
    return false;
  }

  /**
   * @description
   * 対象セクションの項目を非活性表示にすべきかどうかを判定します。
   * @param sectionName セクション名
   * @param [itemId=null] 項目ID
   * @returns 非活性表示にすべき項目である場合には`true`を返します
   */
  isVisibilityInactive(sectionName: string, itemId: string | null = null): boolean {
    return this.awagContext.isNavigateError();
  }

  /**
   * 対象セクションの項目に対する非表示または非活性表示の設定を取得します。
   * @param sectionName セクション名
   * @param [itemId=null] 項目ID
   * @returns 
   */
  getVisibility(sectionName: string, itemId: string | null = null): AwagVisibility {
    itemId = itemId ?? '*'
    return {
      sectionName: sectionName,
      itemId: itemId,
      hidden: this.isVisibilityHidden(sectionName, itemId),
      inactive: this.isVisibilityInactive(sectionName, itemId)
    }
  }

  /**
   * @description
   * 元のモデルを更新データを含むモデルで上書きします。
   * - 元のモデルにないプロパティは作成されます
   * - 上書き処理は単一階層のみです
   * - allowsのエントリーはmodel_name:update_nameの書式で異なるキーのプロパティをマージすることができます
   * @param model 元のモデル
   * @param updates 更新データを含むJSON
   * @param allows 上書き許可プロパティ、未指定の場合や空の場合は全て
   * @returns 上書き更新された
   */
  mergeModel(model: any, updates: any, allows: string[] | null = []): any {
    // 全量マージ
    if (allows === null || allows.length === 0) {
      Object.keys(updates).forEach(key => {
        model[key] = updates[key];
      });
    }
    // 許可対象のみマージ
    else {
      allows.forEach(key => {
        const [key1, key2] = key.split(':');
        const key1Parts = key1.split('.');
        const key2Parts = key2.split('.');
        let value = updates;
        key2Parts.forEach(part => {
          if (value) value = value[part];
        });
        if (!value) return;
        let current = model;
        key1Parts.forEach((part, index) => {
          if (index === key1Parts.length - 1) {
            current[part] = value;
          } else {
            current[part] = current[part] ?? {};
            current = current[part];
          }
        });
      });
    }
    return model;
  }

}
