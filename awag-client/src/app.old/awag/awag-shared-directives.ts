/* Generated by AWAG */
import { AfterViewChecked, AfterViewInit, Directive, ElementRef, EventEmitter, HostListener, Input, NgModule, OnChanges, OnDestroy, OnInit, Optional, Output } from '@angular/core';
import { AbstractControl, NG_VALIDATORS, NgModel, ValidationErrors, Validator } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { Subscription } from 'rxjs';

import { AwagListController } from './awag-listcontroller';
import { AwagVisibilityState } from './awag-visibility.service';
import { AwagLoggerService } from './logger/awag-logger.service';
/**
 * AwagValidityBase
 */
@Directive({})
abstract class AbstractValidityBase implements OnInit, OnDestroy {
  // Subscription
  protected subscription: Subscription = new Subscription();
  // インスタンス化
  constructor(
    protected el: ElementRef,
    protected ngModel: NgModel
  ) {}
  // 初期化
  ngOnInit(): void {
    this.subscription.add(this.ngModel.control.valueChanges.subscribe(value => {
      this.changeValidity();
    }));
  }
  // 破棄
  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
  // 検証結果の反映
  protected changeValidity(): void {
    setTimeout(()=> {
      const isList = this.el.nativeElement.closest('.awag-table');
      const pristine = isList ? false : this.ngModel.pristine;
      if ((!this.el.nativeElement.validity.valid || !this.ngModel.valid) && !pristine && !this.el.nativeElement.disabled) {
        this.findClosestElement(this.el.nativeElement, '.awag-validity').forEach(element => {
          element.classList.add('is-invalid');
        });
      } else {
        this.findClosestElement(this.el.nativeElement, '.awag-validity').forEach(element => {
          element.classList.remove('is-invalid');
        });
      }
    });
  }
  // 指定された要素を親に向かって再帰的に検索する
  private findClosestElement(element: HTMLElement, selector: string): any[] {
    const result = [];
    let el: HTMLElement | null = element;
    while (el) {
      if (el.matches(selector)) {
        result.push(el);
      }
      el = el.parentElement;
    }
    return result;
  }
}
/**
 * Text
 */
@Directive({
  selector: '[awagText]'
})
export class AwagTextDirective extends AbstractValidityBase implements AfterViewInit {
  // min, max, step属性の変化を検知
  private observer: MutationObserver | null = null;
  // インスタンス化
  constructor(
    protected override el: ElementRef,
    protected override ngModel: NgModel
  ) {
    super(el, ngModel);
  }
  // 属性の変化を検知
  ngAfterViewInit(): void {
    // min, max, step属性の変化を検知
    if (this.el.nativeElement.getAttribute('min') != null || this.el.nativeElement.getAttribute('max') != null || this.el.nativeElement.getAttribute('step') != null) {
      this.observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          if (mutation.type === 'attributes' && (mutation.attributeName === 'min' || mutation.attributeName === 'max' || mutation.attributeName === 'step')) {
            this.changeValidity();
          }
        });
      });
      this.observer.observe(this.el.nativeElement, { attributes: true });
    }
  }
}
/**
 * Radio
 */
@Directive({
  selector: '[awagRadio]'
})
export class AwagRadioDirective extends AbstractValidityBase {
  // インスタンス化
  constructor(
    protected override el: ElementRef,
    protected override ngModel: NgModel
  ) {
    super(el, ngModel);
  }
}
/**
 * Select
 */
@Directive({
  selector: '[awagSelect]'
})
export class AwagSelectDirective extends AbstractValidityBase {
  // インスタンス化
  constructor(
    protected override el: ElementRef,
    protected override ngModel: NgModel
  ) {
    super(el, ngModel);
  }
}
/**
 * Checkbox
 */
@Directive({
  selector: '[awagCheckbox]'
})
export class AwagCheckboxDirective extends AbstractValidityBase implements OnInit {
  // チェック時の値
  @Input() trueValue = '';
  // 非チェック時の値
  @Input() falseValue = '';
  // 文字列値の入力
  @Input()
  set awagCheckbox(value: string) {
    setTimeout(() => {
      this.ngModel.control.setValue(value == this.trueValue);
      this.changeValidity();
    });
  }
  // 文字列値の出力
  @Output() awagCheckboxChange = new EventEmitter<string>();
  // リストチェック処理
  @Output() listCheck = new EventEmitter<any>();
  // インスタンス化
  constructor(
    protected override el: ElementRef,
    protected override ngModel: NgModel
  ) {
    super(el, ngModel);
  }
  // 初期化
  override ngOnInit(): void {
    super.ngOnInit();
    this.subscription.add(this.ngModel.control.valueChanges.subscribe(value => {
      if (value != null) {
        this.awagCheckboxChange.emit(value ? this.trueValue : this.falseValue);
        this.listCheck.emit({
          checked: value,
          checkValue: this.trueValue,
          uncheckValue: this.falseValue
        });
      }
    }));
  }
}
/**
 * File
 */
@Directive({
  selector: '[awagFile]',
  exportAs: 'awagFile'
})
export class AwagFileDirective {
  // ファイルの入出力
  @Input() awagFile: any;
  @Output() awagFileChange = new EventEmitter<any>();
  // インスタンス化
  constructor(
    private readonly el: ElementRef
  ) {
  }
  // ファイル選択時にファイルを設定
  @HostListener('change', ['$event']) onChange(event: Event) {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length > 0) {
      this.awagFileChange.emit(input.files);
    } else {
      this.awagFileChange.emit(null);
    }
  }
  // 削除
  delete(index: number) {
    const element = this.el.nativeElement;
    if (element.files) {
      // 指定されたIDに対するファイル一覧(FileList)から指定されたインデックスのファイルを除去
      const newDataTransfer = new DataTransfer();
      for(const file of element.files){
        newDataTransfer.items.add(file);
      }
      newDataTransfer.items.remove(index);
      // 0件になったらファイル一覧(FileList)を除去
      if (newDataTransfer.files.length == 0) {
        element.value = '';
      }
      // 1件以上なら処理結果を反映
      else {
        element.files = newDataTransfer.files;
      }
      // 変更イベントを送信
      element.dispatchEvent(new Event('change'));
    }
  }
}
/**
 * Preview
 */
@Directive({
  selector: '[awagPreview]'
})
export class AwagPreviewDirective {
  // プレビューの宛先
  @Input() awagPreview: string | null = null;
  // ファイル選択時にプレビューを表示
  @HostListener('change', ['$event']) onChange(event: Event) {
    if (!this.awagPreview) {
      return;
    }
    const input = event.target as HTMLInputElement;
    const element = document.querySelector(this.awagPreview) as HTMLInputElement;
    if (input.files && input.files.length > 0) {
      const element = document.querySelector(this.awagPreview) as HTMLInputElement;
      if (element != null && /image.*/.exec(input.files[0].type)) {
        const reader = new FileReader();
        reader.addEventListener('load', () => {
          element.src = reader.result as string;
          element.classList.remove('awag-hidden');
        }, false);
        reader.readAsDataURL(input.files[0]);
      }
    } else {
      element.src = '';
    }
  }
}
/**
 * Image
 */
@Directive({
  selector: '[awagImage]'
})
export class AwagImageDirective implements OnDestroy {
  @Input()
  set awagImage(src: string) {
    const elem = this.el.nativeElement;
    // 正常応答
    const successFunc = function (blob: Blob) {
      const cType = blob.type;
      elem.removeAttribute('src');
      if (cType.indexOf('image') === -1) {
        return;
      }
      const reader = new FileReader();
      reader.onload = function () {
        elem.setAttribute('src', reader.result);
      };
      reader.readAsDataURL(blob);
    };
    // エラー応答
    const errorFunc = function (httpResponse: any) { // NOSONAR
    };
    // イメージ取得
    this.http.get(src, { responseType: 'blob' }).subscribe({
      next: (response) => successFunc(response),
      error: (error) => errorFunc(error)
    });
  }
  // インスタンス化
  constructor(
    private readonly el: ElementRef,
    private readonly http: HttpClient) {
  }
  // 破棄
  ngOnDestroy(): void {
    this.el.nativeElement = null;
  }
}
/**
 * FocusTrap
 */
@Directive({
  selector: '[awagFocusTrap]'
})
export class AwagFocusTrapDirective implements AfterViewInit, OnDestroy {
  // インスタンス化
  constructor(
    private readonly el: ElementRef,
  ) {
  }
  // 初期化
  ngAfterViewInit() {
    const focusableElements = this.el.nativeElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const lastElement = focusableElements[focusableElements.length - 1];
    lastElement.focus();
  }
  // 破棄
  ngOnDestroy(): void {
    this.el.nativeElement = null;
  }
  // キーボードイベント
  @HostListener('keydown', ['$event'])
  handleKeyboardEvent(event: KeyboardEvent) {
    if (event.key === 'Tab') {
      const focusableElements = this.el.nativeElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];
      if (event.shiftKey && document.activeElement === firstElement) {
        // 最終要素へのフォーカス移動
        lastElement.focus();
        event.preventDefault();
      } else if (!event.shiftKey && document.activeElement === lastElement) {
        // 先頭要素へのフォーカス移動
        firstElement.focus();
        event.preventDefault();
      }
    }
    if (event.key === 'Escape') {
      (document.querySelector('#awag-modal-button--close') as HTMLButtonElement)?.click();
    }
  }
}
/**
 * SortTable
 */
@Directive({
  selector: '[awagSortTable]'
})
export class AwagSortTableDirective implements OnInit, OnDestroy {
  private readonly subscription = new Subscription();
  // AwagListController
  @Input('awagSortTable') listCtrl: AwagListController | null = null;
  // ソートキー
  @Input() sortKey = '$$awagIndex';
  // インスタンス化
  constructor(
    private readonly el: ElementRef
  ) {
  }
  // 初期化
  ngOnInit(): void {
    this.subscription.add(this.listCtrl?.event.subscribe(eventName => {
      if (eventName == 'setupPagination') {
        this.reset();
      }
    }));
  }
  // 破棄
  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
  // ファイル選択時にファイル名を設定
  @HostListener('click') onClick() {
    this.listCtrl?.sortList(this.sortKey);
    const sortKeyAfter = this.listCtrl?.sortKey;
    const sort = (sortKeyAfter?.startsWith('+')) ? 'ascending' : (sortKeyAfter?.startsWith('-')) ? 'descending' : 'none'; // NOSONAR
    this.reset();
    this.el.nativeElement.closest('th').setAttribute('aria-sort', sort);
  }
  private reset() {
    this.el.nativeElement.closest('thead').querySelectorAll('th').forEach((element: any) => {
      element.setAttribute('aria-sort', 'none');
    });
  }
}
/**
 * StickyTable
 */
@Directive({
  selector: '[awagStickyTable]'
})
export class AwagStickyTableDirective implements AfterViewChecked, OnDestroy {
  // 左側の固定列数
  @Input() awagLeftFixedColumns?: number;
  // 右側の固定列数
  @Input() awagRightFixedColumns?: number;
  // ヘッダー固定列に付与するCSSクラス名
  private readonly awagFixedheaderClass = 'awag-fixed-table__header';
  // ボディ固定列に付与するCSSクラス名
  private readonly awagFixedcolumnClass = 'awag-fixed-table__column';
  // ヘッダー右側固定列の終端に付与するCSSクラス名
  private readonly awagFixedheaderRightEndClass = 'awag-fixed-table__header--right-end';
  // ボディ右側固定列の終端に付与するCSSクラス名
  private readonly awagFixedcolumnRightEndClass = 'awag-fixed-table__column--right-end';
  // ヘッダー左側固定列の終端に付与するCSSクラス名
  private readonly awagFixedheaderLeftEndClass = 'awag-fixed-table__header--left-end';
  // ボディ左側固定列の終端に付与するCSSクラス名
  private readonly awagFixedcolumnLeftEndClass = 'awag-fixed-table__column--left-end';
  // 対象テーブルの内容変更検知
  private domObserver: MutationObserver | null = null;
  // 対象テーブルのリサイズ検知
  private resizeObserver: ResizeObserver | null = null;
  // デザインシステム毎の補正値
  private readonly leftAdjusted = 1;
  private readonly rightAdjusted = 1;
  // インスタンス化
  constructor(
    private readonly el: ElementRef,
    private readonly awagLogger: AwagLoggerService,
  ) {
    const table = this.el.nativeElement as HTMLTableElement;
    this.resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        this.awagLogger.develop('AwagStickyTableDirective, resize');
        this.process();
      });
    });
    this.resizeObserver.observe(table);
    this.awagLogger.develop('AwagStickyTableDirective, start resize observing');
  }
  // tbodyのDOM内容変更検知
  ngAfterViewChecked() {
    if (!this.domObserver) {
      const table = this.el.nativeElement as HTMLTableElement;
      if (table.tBodies?.[0]) {
        this.domObserver = new MutationObserver((mr: MutationRecord[]) => {
          this.awagLogger.develop('AwagStickyTableDirective, mutation');
          this.process();
        });
        this.domObserver.observe(table.tBodies[0], {childList: true});
        this.awagLogger.develop('AwagStickyTableDirective, start mutation observing');
      }
    }
  }
  // リサイズ検知とDOM内容変更検知を終了
  ngOnDestroy() {
    const table = this.el.nativeElement as HTMLTableElement;
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(table);
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
      this.awagLogger.develop('AwagStickyTableDirective, end resize observing');
    }
    if (this.domObserver) {
      this.domObserver.disconnect();
      this.domObserver = null;
      this.awagLogger.develop('AwagStickyTableDirective, end mutation observing');
    }
    this.el.nativeElement = null;
  }
  // 左側の列固定、右側の列固定
  process() {
    this.awagLogger.develop('AwagStickyTableDirective, processing. right=' + this.awagRightFixedColumns + ', left=' + this.awagLeftFixedColumns);
    const table = this.el.nativeElement as HTMLTableElement;
    if (this.awagLeftFixedColumns) {
      // 左固定処理:thead内のrowを処理
      if (table.tHead) {
        this.setFixedColumns(table.tHead, this.awagFixedheaderClass, this.awagFixedheaderRightEndClass, 'left', this.awagLeftFixedColumns, table.tHead.rows.length, false);
      }
      // 左固定処理:tbody内のrowを処理
      if (table.tBodies) {
        this.setFixedColumns(table.tBodies[0], this.awagFixedcolumnClass, this.awagFixedcolumnRightEndClass, 'left', this.awagLeftFixedColumns, table.tBodies[0].rows.length, true);
      }
    }
    if (this.awagRightFixedColumns) {
      // 右固定処理:thead内のrowを処理
      if (table.tHead && this.awagRightFixedColumns) {
        this.setFixedColumns(table.tHead, this.awagFixedheaderClass, this.awagFixedheaderLeftEndClass, 'right', this.awagRightFixedColumns, table.tHead.rows.length, false);
      }
      // 右固定処理:tbody内のrowを処理
      if (table.tBodies && this.awagRightFixedColumns) {
        this.setFixedColumns(table.tBodies[0], this.awagFixedcolumnClass, this.awagFixedcolumnLeftEndClass, 'right', this.awagRightFixedColumns, table.tBodies[0].rows.length, false);
      }
    }
  }
  // 左側の列固定、右側の列固定
  private setFixedColumns(target: HTMLTableSectionElement, columnClass: string, endClass: string, leftOrRight: string, fixedColumns: number, rowLength: number, isCachePosition: boolean) {
    // 1行目で各列に適用するleft, rightの値を先に計算
    let cellMaxIndex = target.rows[0]?.cells.length - 1;
    let positions: number[] = this.getPositions(target.rows[0], cellMaxIndex, leftOrRight, fixedColumns);
    // 計算済みのleft,rightの値とclass属性を適用
    const columnClassList = columnClass.split(' ');
    for (let row = 0; row < rowLength; row++) {
      if (!isCachePosition) { // キャッシュしない場合は行単位で再計算
        cellMaxIndex = target.rows[row]?.cells.length - 1;
        positions = this.getPositions(target.rows[row], cellMaxIndex, leftOrRight, fixedColumns);
      }
      for (let col = 0; col <= cellMaxIndex; col++) {
        const cell: any = target.rows[row].cells[this.getCellIndex(col, cellMaxIndex, leftOrRight)];
        if (col <= fixedColumns - 1) {
          // left,right指定と固定用クラスを設定
          if (col > 0) {
            cell.style[leftOrRight] = positions[col] + 'px';
          } else {
            cell.style[leftOrRight] = '0px'
          }
          if (columnClassList.length > 1) {
            cell.classList.add(columnClassList[0], columnClassList[1]);
          } else {
            cell.classList.add(columnClass);
          }
        }
        // 固定端ならボーダー用クラスを設定
        if (cell != null && col == fixedColumns - 1) {
          cell.classList.add(endClass);
        }
      }
    }
  }
  // 左または右の列固定のインデックス値
  private getCellIndex(index: number, cellMaxIndex: number, leftOrRight: string): number {
    let cellIndex = -1;
    if (leftOrRight === 'left') {
      cellIndex = index;
    }
    if (leftOrRight === 'right') {
      cellIndex = cellMaxIndex - index;
    }
    if (cellIndex < 0) {
      throw new Error('The cellIndex must always be greater than or equal to 0.');
    }
    return cellIndex;
  }
  // 列毎の固定位置情報
  private getPositions(row: any, cellMaxIndex: number, leftOrRight: string, fixedColumns: number) {
    const positions: number[] = [];
    for (let col = 0; col <= cellMaxIndex; col++) {
      if (col <= fixedColumns - 1) {
        positions[col] = 0;
        if (col > 0) {
          if (leftOrRight === 'left') {
            positions[col] = positions[col - 1] + row?.cells[this.getCellIndex(col, cellMaxIndex, leftOrRight) - 1].clientWidth + this.leftAdjusted;
          }
          if (leftOrRight === 'right') {
            positions[col] = positions[col - 1] + row?.cells[this.getCellIndex(col, cellMaxIndex, leftOrRight) + 1].clientWidth + this.rightAdjusted;
          }
        }
      }
    }
    return positions;
  }
}
/**
 * Visibility
 */
@Directive({
  'selector': '[awagVisibility]',
})
export class AwagVisibilityDirective implements OnChanges {
  // Visibility状態
  @Input() awagVisibility: AwagVisibilityState | null = null;
  // インスタンス化
  constructor(
    private readonly el: ElementRef
  ) {
  }
  // 変更検知処理
  ngOnChanges() {
    // 非表示
    if (this.awagVisibility == AwagVisibilityState.Hidden) {
      this.el.nativeElement.parentElement.classList.add('awag-hidden');
    }
    // 非活性
    else if (this.awagVisibility == AwagVisibilityState.Inactive) {
      setTimeout(() => {
        this.markDisabled(this.el.nativeElement).querySelectorAll('input,button,textarea,select,a').forEach((child: any) => {
          this.markDisabled(child);
        });
      });
    }
    // 活性
    else if (this.awagVisibility == AwagVisibilityState.Active) {
      setTimeout(() => {
        this.markEnabled(this.el.nativeElement).querySelectorAll('input,button,textarea,select,a').forEach((child: any) => {
          this.markEnabled(child);
        });
      });
    }
  }
  // 要素を無効に設定
  private markDisabled(element: HTMLElement): HTMLElement {
    element.classList.add('awag-disabled');
    element.setAttribute('aria-disabled', 'true');
    element.setAttribute('tabindex', '-1');
    if ('disabled' in element) {
      element.disabled = true;
    }
    return element;
  }
  // 要素を有効に設定
  private markEnabled(element: HTMLElement): HTMLElement {
    element.classList.remove('awag-disabled');
    element.setAttribute('aria-disabled', 'false');
    element.setAttribute('tabindex', '0');
    if ('disabled' in element) {
      element.disabled = false;
    }
    return element;
  }
}
/* eslint-disable @angular-eslint/directive-selector */
@Directive({
  selector: `
    input[type=search],
    input[type=url],
    input[type=tel],
    input[type=email],
    input[type=number],
    input[type=datetime-local],
    input[type=date],
    input[type=month],
    input[type=week],
    input[type=time],
    input[type=range],
    input[type=color]`,
  providers: [{
    provide: NG_VALIDATORS,
    useExisting: AwagHtml5ValidationDirective,
    multi: true,
  }],
})
export class AwagHtml5ValidationDirective implements Validator, AfterViewInit {
  // min, max, step属性の変化を検知
  private observer: MutationObserver | null = null;
  // AbstractControl cache
  private ngControl: AbstractControl | null = null;
  // インスタンス化
  constructor(
    private readonly el: ElementRef,
  ) {
  }
  // 検証処理
  validate(control: AbstractControl): ValidationErrors | null {
    this.ngControl = control;
    const element = this.el.nativeElement;
    const error = {
      'nativeValidation': {
        'validity': element.validity,
        'validationMessage': element.validationMessage
      }
    }
    return !element.validity.valid ? error : null;
  }
  // 監視の初期化
  ngAfterViewInit(): void {
    // min, max, step属性の変化を検知
    if (this.el.nativeElement.getAttribute('min') != null || this.el.nativeElement.getAttribute('max') != null || this.el.nativeElement.getAttribute('step') != null) {
      this.observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          if (mutation.type === 'attributes' && (mutation.attributeName === 'min' || mutation.attributeName === 'max' || mutation.attributeName === 'step')) {
            this.updateErrors();
          }
        });
      });
      this.observer.observe(this.el.nativeElement, { attributes: true });
    }
  }
  // エラーの更新
  private updateErrors() {
    if (this.ngControl) {
      const errors = { ...this.ngControl.errors };
      const result = this.validate(this.ngControl);
      if (result) {
        errors['nativeValidation'] = result;
      } else {
        delete errors['nativeValidation'];
      }
      this.ngControl.setErrors(Object.keys(errors).length ? errors : null);
    }
  }
}

@Directive({
  selector: `
    input[type=search],
    input[type=url],
    input[type=tel],
    input[type=email],
    input[type=number],
    input[type=datetime-local],
    input[type=date],
    input[type=month],
    input[type=week],
    input[type=time],
    input[type=range],
    input[type=color]`,
})
export class AwagHtml5IncompleteDirective {
  constructor(
    private readonly el: ElementRef,
    @Optional() private readonly ngModel: NgModel,
  ) {
  }
  @HostListener('blur') onBlur() {
    const input = this.el.nativeElement as HTMLInputElement;
    const control = this.ngModel?.control;
    if (input.validity.valid) {
      control?.setErrors(null);
    } else if (!control?.value) {
      control?.setErrors({ ...(control?.errors ?? {}), incomplete: true });
    }
  }
}
/* eslint-enable @angular-eslint/directive-selector */
@NgModule({
  imports: [
    AwagTextDirective,
    AwagRadioDirective,
    AwagSelectDirective,
    AwagCheckboxDirective,
    AwagFileDirective,
    AwagPreviewDirective,
    AwagImageDirective,
    AwagFocusTrapDirective,
    AwagSortTableDirective,
    AwagStickyTableDirective,
    AwagVisibilityDirective,
    AwagHtml5ValidationDirective,
    AwagHtml5IncompleteDirective,
  ],
  exports: [
    AwagTextDirective,
    AwagRadioDirective,
    AwagSelectDirective,
    AwagCheckboxDirective,
    AwagFileDirective,
    AwagPreviewDirective,
    AwagImageDirective,
    AwagFocusTrapDirective,
    AwagSortTableDirective,
    AwagStickyTableDirective,
    AwagVisibilityDirective,
    AwagHtml5ValidationDirective,
    AwagHtml5IncompleteDirective,
  ]
})
export class AwagSharedDirectivesModule {
}
