/* Generated by AWAG */
import { Injectable } from '@angular/core';

import { AwagError } from './awag-error';
import { AwagModalContext } from './awag-modal-context';
import { AwagSubContext } from './awag-subcontext';
import { AwagUser } from './awag-user';

/**
 * @description
 * AwagContextServiceは画面コンポーネントやサービスで使用されるコンテキストに関連する様々なデータを管理するサービスです。
 */
@Injectable({
  providedIn: 'root'
})
export class AwagContextService {

  /**
   * サブユースケース呼び出し用のContextデータ
   */
  private subContext: AwagSubContext | null = null;

  /**
   * 複数のSubContextを管理するためのマップ
   */
  private subContextMap: Map<string, string> = new Map();

  /**
   * 次画面用のModelデータ
   */
  private nextModel: any = {};

  /**
   * 次画面のURL
   */
  private nextUrl: string | null = null;

  /**
   * API呼び出しをキャンセルするためのフラグ
   */
  private cancelApi = false;

  /**
   * home画面コンポーネント向けのメッセージ
   */
  private message = 'awag.label.sc.home.topmessage';

  /**
   * 各画面の直近表示データ
   */
  private vModels: any = {};

  /**
   * 次画面に表示するエラー情報
   */
  private error: AwagError | null = null;

  /**
   * モーダル表示に関するコンテキスト情報を保持するオブジェクトです
   */
  private modalContext: AwagModalContext | null = null;

  /**
   * ユーザー情報
   */
  private user: AwagUser = AwagUser.DEFAULT;

  /**
   * 画面毎のタブの選択状態を保持する
   */
  private tabState: Map<string, number> = new Map();

  /**
   * 現在の画面の状態を管理するキー項目
   */
  private screenKey: string = '';

  /**
   * 最後の画面遷移がRouterで制御されたものであるかどうか
   * falseの場合はブラウザバックやURL指定のアクセスと判定
   */
  private navigateFromRouter = false;

  /**
   * 不正な画面遷移が行われている状態であるかどうか
   */
  private navigateError = false;

  /**
   * メニューリンク選択時の処理中であるかどうか
   */
  private menuLinkProcessing = false;

  /**
   * @description
   * モーダル表示に関するコンテキスト情報を取得します。
   * @returns {AwagModalContext} モーダル表示に関するコンテキスト情報
   */
  getModalContext(): AwagModalContext | null {
    return this.modalContext;
  }

  /**
   * @description
   * モーダル表示に関するコンテキスト情報を設定します。
   * @param {AwagModalContext} modalContext モーダル表示に関するコンテキスト情報
   */
  setModalContext(modalContext: AwagModalContext | null) {
    if (modalContext == null) {
      this.modalContext?.terminate();
    }
    this.modalContext = modalContext;
  }

  /**
   * @description
   * サブユースケース呼び出し用のContextデータを取得します。
   * @returns {AwagSubContext} サブユースケース呼び出し用のContextデータ
   */
  getSubContext(): AwagSubContext | null {
    return this.subContext;
  }

  /**
   * @description
   * サブユースケース呼び出し用のContextデータを設定します。
   * @param {AwagSubContext} subContext サブユースケース呼び出し用のContextデータ
   * @param force 状態に関わらずnull設定する場合
   */
  setSubContext(subContext: AwagSubContext | null, force = false) {
    if (subContext != null) {
      this.subContextMap.set(subContext.getId(), JSON.stringify(subContext));
      // subContextIdをサブユースケース画面のURLに付加
      if (this.nextUrl) {
        this.nextUrl = (this.nextUrl.indexOf('?') < 0) ? this.nextUrl + '?scid=' + subContext.getId(): this.nextUrl + '&scid=' + subContext.getId();
      }
    }
    if (subContext != null) {
      this.subContext = subContext;
    } else if (this.subContext?.isReturn() || force) {
      this.subContext = null;
    }
  }

  /**
   * @description
   * 次画面用のModelデータを取得します。
   * @returns {*} 次画面用のModelデータ
   */
  getNextModel(): any {
    return this.nextModel;
  }

  /**
   * @description
   * 次画面用のModelデータを設定します。
   * modelに含まれるデータのタイプはプリミティブ型 (Boolean/Null/Number/String) または array型である必要があります。 他のデータ型のデータは欠落または削除される可能性があります。
   * @param {*} model 次画面用のModelデータ
   */
  setNextModel(model: any) {
    this.nextModel = JSON.parse(JSON.stringify(model));
  }

  /**
   * @description
   * 次画面のURLを取得します。
   * @returns {string} 次画面のURL
   */
  getNextUrl(): string | null {
    return this.nextUrl;
  }

  /**
   * @description
   * 次画面のURLを設定します。
   * @param {string} url 次画面のURL
   */
  setNextUrl(url: string | null) {
    this.nextUrl = url;
  }

  /**
   * @description
   * API呼び出しをキャンセルするためのフラグを取得します。
   * @returns {boolean} API呼び出しをキャンセルするためのフラグ
   */
  isCancelApi(): boolean {
    return this.cancelApi;
  }

  /**
   * @description
   * API呼び出しをキャンセルするためのフラグを設定します。
   * @param {boolean} bool API呼び出しをキャンセルするためのフラグ
   */
  setCancelApi(bool: boolean) {
    this.cancelApi = bool;
  }

  /**
   * @description
   * home画面コンポーネント向けのメッセージを取得します。
   * @returns {string} home画面コンポーネント向けのメッセージ
   */
  getMessage(): string {
    return this.message;
  }

  /**
   * @description
   * home画面コンポーネント向けのメッセージを設定します。
   * @param {string} text home画面コンポーネント向けのメッセージ
   */
  setMessage(text: string) {
    this.message = text;
  }

  /**
   * @description
   * 指定された画面の表示データを取得します。
   * @param {string} screenName 取得対象の画面名
   * @returns {*} 指定した画面の表示データ
   */
  getVModel(screenName: string): any {
    return this.vModels[screenName];
  }

  /**
   * @description
   * 指定された画面の表示データを設定します。
   * @param {string} screenName 設定対象の画面名
   * @param {*} 指定した画面の表示データ
   */
  setVModel(screenName: string, model: any) {
    if (this.navigateError) {
      return;
    }
    this.vModels[screenName] = model;
  }

  /**
   * @description
   * 次画面に表示するエラー情報を取得します。
   * @returns {AwagError} 次画面に表示するエラー情報
   */
  getError(): AwagError | null {
    return this.error;
  }

  /**
   * @description
   * 次画面に表示するエラー情報を設定します。
   * @param {AwagError} error 次画面に表示するエラー情報
   */
  setError(error: AwagError | null) {
    this.error = error;
  }

  /**
   * @description
   * ユーザー情報を設定します。
   * @param newUser ユーザー情報
   */
  setUser(newUser: AwagUser) {
    this.user = newUser;
  }

  /**
   * @description
   * ユーザー情報を取得します。
   * @returns  ユーザー情報
   */
  getUser(): AwagUser {
    return this.user;
  }

  /**
   * 選択されているタブのインデックスを設定します。
   * @param screenName 画面名
   * @param index 選択されているタブのインデックス
   */
  public setActiveTabIndex(screenName: string, index: number): void {
    this.tabState.set(screenName, index);
  }

  /**
   * 選択されているタブのインデックスを返します。
   * @param screenName 画面名
   * @returns 選択されているタブのインデックス
   */
  public getActiveTabIndex(screenName: string): number {
    return this.tabState.get(screenName) ?? 0;
  }

  /**
   * 現在の画面キー項目を設定します。
   * @param screenKey 現在の画面キー項目
   */
  public setScreenKey(screenKey: string) {
    this.screenKey = screenKey;
  }

  /**
   * 現在の画面キー項目を返します。
   * @returns 現在の画面キー項目
   */
  public getScreenKey(): string {
    return this.screenKey;
  }

  /**
   * 最後の画面遷移がRouterで制御されたものであるかどうかを返します。Routerで画面遷移した場合にはtrueが返ります。
   * @returns 状態
   */
  isNavigateFromRouter(newState: boolean | undefined = undefined): boolean {
    const state = this.navigateFromRouter;
    if (newState !== undefined) {
      this.navigateFromRouter = newState;
    }
    return state;
  }

  /**
   * 最後の画面遷移がRouterで制御されたものであるかどうかを設定します。
   * @param state 状態
   */
  setNavigateFromRouter(state: boolean): void {
    this.navigateFromRouter = state;
  }

  /**
   * 不正な画面遷移が行われている状態であるかどうかを返します。
   * @returns 状態
   */
  isNavigateError(): boolean {
    return this.navigateError;
  }

  /**
   * 不正な画面遷移が行われている状態であるかどうかを設定します。
   * @param state 状態
   */
  setNavigateError(state: boolean): void {
    this.navigateError = state;
  }

  /**
   * メニューリンク選択時の処理中であるかどうかを返します。
   * @returns 状態
   */
  isMenuLinkProcessing(): boolean {
    return this.menuLinkProcessing;
  }

  /**
   * メニューリンク選択時の処理中であるかどうかを設定します。
   * @param state 状態
   */
  setMenuLinkProcessing(state: boolean): void {
    this.menuLinkProcessing = state;
  }

  /**
   * URLの情報からSubContextを再構築します
   * @param awagContext コンテキスト情報
   * @param router ルーター
   */
  restoreSubContext(subContextId: string | null): void {
    if (subContextId && subContextId != this.subContext?.getId()) {
      const subContextData = <string>this.subContextMap.get(subContextId);
      if (subContextData) {
        this.subContext = JSON.parse(subContextData, (key, value) => {
          return (key === '') ? Object.assign(new AwagSubContext(), value): value;
        });
      } else {
        this.navigateError = true;
      }
    }
  }

  /**
   * User情報以外をクリアします。
   */
  public clear(): void {
    this.subContext = null;
    this.nextModel = {};
    this.nextUrl = null;
    this.cancelApi = false;
    this.vModels = {};
    this.error = null;
    this.modalContext = null;
    this.tabState = new Map();
    this.screenKey = '';
    this.subContextMap = new Map();
  }

}
